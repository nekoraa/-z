import os
import torch
import numpy as np
import re
from 滤波器 import 随机生成文件夹名, 带通滤波器, 带阻滤波器, 带阻滤波器2


def 处理采样信号(采样信号, 数字序列, 采样率=500):
    # 创建"训练数据"文件夹
    根文件夹 = "训练数据"
    if not os.path.exists(根文件夹):
        os.makedirs(根文件夹)

    # 生成随机的10位数字作为文件夹名称
    随机文件夹名 = 随机生成文件夹名()
    文件夹路径 = os.path.join(根文件夹, 随机文件夹名)
    os.makedirs(文件夹路径)

    # 遍历每个通道
    通道数 = len(采样信号)
    for 通道号 in range(通道数):
        通道数据 = 采样信号[通道号]
        子文件夹名 = f'{数字序列}{通道号 + 1}通道'
        子文件夹路径 = os.path.join(文件夹路径, 子文件夹名)
        os.makedirs(子文件夹路径)

        # 对信号进行滤波
        通道数据 = 带通滤波器(通道数据)
        通道数据 = 带阻滤波器(通道数据)
        通道数据 = 带阻滤波器2(通道数据)

        # 生成时频数组
        时频数组 = 生成时频数组(通道数据, 采样率)

        # 保存时频数组为.npy文件
        文件名 = f"时频数组_通道{通道号 + 1}.npy"
        文件路径 = os.path.join(子文件夹路径, 文件名)
        np.save(文件路径, 时频数组)


def 验证时频数组(文件夹数):
    # 定义测试路径
    测试路径 = "训练数据"

    # 获取 '训练数据' 目录下的所有第一层子文件夹
    第一层子目录列表 = [f for f in os.listdir(测试路径) if os.path.isdir(os.path.join(测试路径, f))]

    # 检查文件夹数是否超出范围
    if 文件夹数 >= len(第一层子目录列表):
        print(f"索引 {文件夹数} 超出范围，当前第一层子目录数为 {len(第一层子目录列表)}")
        return

    # 获取第文件夹数个第一层子文件夹路径
    第一层子文件夹 = 第一层子目录列表[文件夹数]
    第一层子文件夹路径 = os.path.join(测试路径, 第一层子文件夹)

    # 获取第二层子文件夹
    第二层子目录列表 = [f for f in os.listdir(第一层子文件夹路径) if os.path.isdir(os.path.join(第一层子文件夹路径, f))]
    次数 = 0
    # 遍历第二层子文件夹
    for 第二层子文件夹 in 第二层子目录列表:
        第二层子文件夹路径 = os.path.join(第一层子文件夹路径, 第二层子文件夹)

        # 遍历第二层子文件夹中的所有文件
        for 文件名 in os.listdir(第二层子文件夹路径):
            if 文件名.endswith(".npy"):
                文件路径 = os.path.join(第二层子文件夹路径, 文件名)
                # 加载.npy文件
                时频数组 = np.load(文件路径)
                # 扩展数组维度
                时频数组 = np.expand_dims(时频数组, axis=0)
                if 次数 == 0:
                    总时频数组 = 时频数组
                else:
                    总时频数组 = np.concatenate((总时频数组, 时频数组), axis=0)
                # 打印文件信息和数组形状
                # print(f"读取文件: {文件路径}, 数组形状: {时频数组.shape}")
                文件路径1 = 文件路径
                次数 = 次数 + 1
    # print(f"读取文件: {文件路径}, 数组形状: {总时频数组.shape}")

    # 使用正则表达式提取数字
    match = re.search(r"\['\[(\d+)\]'\]", str(文件路径1))

    # 如果找到匹配的数字
    if match:
        # 提取并转换为浮点型
        数字 = float(match.group(1))
        目标数据 = torch.tensor([0, 数字, 5])

    总时频数组 = torch.tensor(总时频数组)
    return 总时频数组.float(), 目标数据.to(torch.int64)

def 随机生成采样信号(采样率=500, 通道数=4, 时长=3):
    """
    随机生成指定通道数的采样信号，每个通道为正弦波与噪声叠加。
    参数：
        采样率: 每秒采样点数，默认500Hz
        通道数: 信号通道数，默认4通道
        时长: 信号时长（秒），默认10秒
    返回：
        采样信号: 一个包含每个通道数据的列表
    """
    时间轴 = np.linspace(0, 时长, 采样率 * 时长, endpoint=False)
    采样信号 = []
    for _ in range(通道数):
        频率 = np.random.uniform(1, 50)  # 随机频率1Hz到50Hz
        信号 = np.sin(2 * np.pi * 频率 * 时间轴)  # 正弦波
        噪声 = np.random.normal(0, 0.1, 时间轴.shape)  # 高斯噪声
        通道数据 = 信号 + 噪声
        采样信号.append(通道数据)
    return 采样信号

def 生成时频数组(信号, 采样率):
    """
    根据输入信号生成时频数组（例如短时傅里叶变换）。
    参数：
        信号: 一维时间序列数据
        采样率: 信号采样率
    返回：
        时频数组: 二维时频表示
    """
    from scipy.signal import spectrogram
    频率, 时间, 时频强度 = spectrogram(信号, fs=采样率, nperseg=256, noverlap=128)
    return 时频强度




# 示例代码
if __name__ == "__main__":
    # 随机生成信号
    生成的信号 = 随机生成采样信号()

    # 处理信号并保存
    处理采样信号(生成的信号, 数字序列="['[4]']")

    # 验证保存的时频数组
    总时频数组, 源数据 = 验证时频数组(0)
    print(总时频数组.dtype)
    print(源数据.dtype)